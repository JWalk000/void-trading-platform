"use strict";exports.id=272,exports.ids=[272],exports.modules={6249:(t,e)=>{Object.defineProperty(e,"l",{enumerable:!0,get:function(){return function t(e,r){return r in e?e[r]:"then"in e&&"function"==typeof e.then?e.then(e=>t(e,r)):"function"==typeof e&&"default"===r?e:void 0}}})},6874:(t,e,r)=>{r.d(e,{f:()=>o});var a=r(3524);class o{constructor(t){this.lastRequestTime=0,this.minRequestInterval=100,this.config=t,this.prisma=new a.PrismaClient,this.baseUrl=t.baseUrl||"https://api.tradelocker.com"}async rateLimit(){let t=Date.now()-this.lastRequestTime;if(t<this.minRequestInterval){let e=this.minRequestInterval-t;await new Promise(t=>setTimeout(t,e))}this.lastRequestTime=Date.now()}async handleBotTradingError(t,e){if(console.error(`TradeLocker Bot Error (${e}):`,t),t.message?.includes("rate limit"))throw Error("Rate limit exceeded. Please wait before retrying.");if(t.message?.includes("insufficient margin"))throw Error("Insufficient margin for trade. Check account balance.");if(t.message?.includes("market closed"))throw Error("Market is closed. Trading not available at this time.");if(t.message?.includes("invalid symbol"))throw Error("Invalid trading symbol. Please check symbol format.");throw Error(`TradeLocker ${e} failed: ${t.message}`)}async testConnection(){try{let t=await this.makeRequest("GET","/v1/accounts");return!0===t.success}catch(t){return console.error("TradeLocker connection test failed:",t),!1}}async getBalance(){try{let t=await this.makeRequest("GET",`/v1/accounts/${this.config.accountId}/balance`);if(t.success)return t.data.map(t=>({currency:t.currency,balance:parseFloat(t.balance),equity:parseFloat(t.equity),margin:parseFloat(t.margin),freeMargin:parseFloat(t.freeMargin),marginLevel:parseFloat(t.marginLevel)}));throw Error("Failed to fetch balance")}catch(t){throw console.error("Error fetching TradeLocker balance:",t),t}}async getCurrentPrice(t){try{await this.rateLimit();let e=await this.makeRequest("GET",`/v1/quotes/${t}`);if(e.success)return parseFloat(e.data.bid);throw Error("Failed to fetch price")}catch(t){throw console.error("Error fetching TradeLocker price:",t),t}}async getHistoricalData(t,e,r=100){try{let a=await this.makeRequest("GET",`/v1/charts/${t}`,{timeframe:e,limit:r});if(a.success)return a.data.map(t=>({timestamp:new Date(t.timestamp),open:parseFloat(t.open),high:parseFloat(t.high),low:parseFloat(t.low),close:parseFloat(t.close),volume:parseFloat(t.volume)}));throw Error("Failed to fetch historical data")}catch(t){throw console.error("Error fetching TradeLocker historical data:",t),t}}async placeMarketOrder(t){try{let e={symbol:t.symbol,side:t.side,type:"market",quantity:t.quantity,timeInForce:t.timeInForce||"GTC"},r=await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/orders`,e);if(r.success)return(t.stopLoss||t.takeProfit)&&await this.addStopLossTakeProfit(r.data.orderId,t),{success:!0,orderId:r.data.orderId,status:r.data.status,filledQuantity:r.data.filledQuantity,averagePrice:r.data.averagePrice};throw Error("Failed to place order")}catch(t){throw console.error("Error placing TradeLocker order:",t),t}}async placeLimitOrder(t){try{if(!t.price)throw Error("Price is required for limit orders");let e={symbol:t.symbol,side:t.side,type:"limit",quantity:t.quantity,price:t.price,timeInForce:t.timeInForce||"GTC"},r=await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/orders`,e);if(r.success)return(t.stopLoss||t.takeProfit)&&await this.addStopLossTakeProfit(r.data.orderId,t),{success:!0,orderId:r.data.orderId,status:r.data.status};throw Error("Failed to place limit order")}catch(t){throw console.error("Error placing TradeLocker limit order:",t),t}}async addStopLossTakeProfit(t,e){try{e.stopLoss&&await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/positions/${t}/stop-loss`,{price:e.stopLoss}),e.takeProfit&&await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/positions/${t}/take-profit`,{price:e.takeProfit})}catch(t){console.error("Error adding stop loss/take profit:",t)}}async closePosition(t,e){try{let r=(await this.getPositions()).find(e=>e.symbol===t);if(!r)throw Error("Position not found");let a=e||r.quantity,o="long"===r.side?"sell":"buy",i=await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/orders`,{symbol:t,side:o,type:"market",quantity:a,timeInForce:"IOC"});if(i.success)return{success:!0,orderId:i.data.orderId,status:i.data.status,closedQuantity:a};throw Error("Failed to close position")}catch(t){throw console.error("Error closing TradeLocker position:",t),t}}async getPositions(){try{let t=await this.makeRequest("GET",`/v1/accounts/${this.config.accountId}/positions`);if(t.success)return t.data.map(t=>({id:t.id,symbol:t.symbol,side:t.side,quantity:parseFloat(t.quantity),entryPrice:parseFloat(t.entryPrice),currentPrice:parseFloat(t.currentPrice),unrealizedPnL:parseFloat(t.unrealizedPnL),stopLoss:t.stopLoss?parseFloat(t.stopLoss):void 0,takeProfit:t.takeProfit?parseFloat(t.takeProfit):void 0,timestamp:new Date(t.timestamp)}));throw Error("Failed to fetch positions")}catch(t){throw console.error("Error fetching TradeLocker positions:",t),t}}async getOrderHistory(t,e=100){try{let r=new URLSearchParams;t&&r.append("symbol",t),r.append("limit",e.toString());let a=await this.makeRequest("GET",`/v1/accounts/${this.config.accountId}/orders?${r}`);if(a.success)return a.data.map(t=>({id:t.id,symbol:t.symbol,side:t.side,type:t.type,quantity:parseFloat(t.quantity),price:parseFloat(t.price),status:t.status,filledQuantity:parseFloat(t.filledQuantity),averagePrice:parseFloat(t.averagePrice),timestamp:new Date(t.timestamp)}));throw Error("Failed to fetch order history")}catch(t){throw console.error("Error fetching TradeLocker order history:",t),t}}async cancelOrder(t){try{if((await this.makeRequest("DELETE",`/v1/accounts/${this.config.accountId}/orders/${t}`)).success)return{success:!0,orderId:t,status:"cancelled"};throw Error("Failed to cancel order")}catch(t){throw console.error("Error cancelling TradeLocker order:",t),t}}async makeRequest(t,e,r){let a=`${this.baseUrl}${e}`,o=Date.now().toString(),i=this.createSignature(t,e,o,r),s={method:t,headers:{"Content-Type":"application/json","X-API-Key":this.config.apiKey,"X-Timestamp":o,"X-Signature":i}};r&&"GET"!==t&&(s.body=JSON.stringify(r));let c=await fetch(a,s),n=await c.json();if(!c.ok)throw Error(`TradeLocker API error: ${n.message||c.statusText}`);return n}createSignature(t,e,a,o){let i=`${t}${e}${a}${o?JSON.stringify(o):""}`;return r(6113).createHmac("sha256",this.config.secretKey).update(i).digest("hex")}async saveConfig(){try{await this.prisma.brokerConfig.upsert({where:{broker:"tradelocker"},update:{apiKey:this.config.apiKey,secretKey:this.config.secretKey,accountId:this.config.accountId,baseUrl:this.config.baseUrl,environment:this.config.environment},create:{broker:"tradelocker",apiKey:this.config.apiKey,secretKey:this.config.secretKey,accountId:this.config.accountId,baseUrl:this.config.baseUrl,environment:this.config.environment}})}catch(t){throw console.error("Error saving TradeLocker config:",t),t}}async loadConfig(){try{let t=await this.prisma.brokerConfig.findUnique({where:{broker:"tradelocker"}});if(t)return this.config={apiKey:t.apiKey,secretKey:t.secretKey,accountId:t.accountId,baseUrl:t.baseUrl,environment:t.environment},this.config;return null}catch(t){return console.error("Error loading TradeLocker config:",t),null}}async placeBotMarketOrder(t){try{await this.rateLimit();let e={symbol:t.symbol,side:t.side,type:"market",quantity:t.quantity,timeInForce:t.timeInForce||"IOC"},r=await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/orders`,e);if(r.success)return console.log(`Bot Trade Executed: ${t.side} ${t.quantity} ${t.symbol} at market`),(t.stopLoss||t.takeProfit)&&await this.addStopLossTakeProfit(r.data.orderId,t),{success:!0,orderId:r.data.orderId,status:r.data.status,filledQuantity:r.data.filledQuantity,averagePrice:r.data.averagePrice,timestamp:new Date};throw Error("Failed to place bot order")}catch(t){return this.handleBotTradingError(t,"market order")}}async placeBotLimitOrder(t){try{if(await this.rateLimit(),!t.price)throw Error("Price is required for limit orders");let e={symbol:t.symbol,side:t.side,type:"limit",quantity:t.quantity,price:t.price,timeInForce:t.timeInForce||"GTC"},r=await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/orders`,e);if(r.success)return console.log(`Bot Limit Order Placed: ${t.side} ${t.quantity} ${t.symbol} at ${t.price}`),(t.stopLoss||t.takeProfit)&&await this.addStopLossTakeProfit(r.data.orderId,t),{success:!0,orderId:r.data.orderId,status:r.data.status,timestamp:new Date};throw Error("Failed to place bot limit order")}catch(t){return this.handleBotTradingError(t,"limit order")}}async closeBotPosition(t,e){try{await this.rateLimit();let r=(await this.getPositions()).find(e=>e.symbol===t);if(!r)throw Error("Position not found for bot to close");let a=e||r.quantity,o="long"===r.side?"sell":"buy",i=await this.makeRequest("POST",`/v1/accounts/${this.config.accountId}/orders`,{symbol:t,side:o,type:"market",quantity:a,timeInForce:"IOC"});if(i.success)return console.log(`Bot Position Closed: ${a} ${t}`),{success:!0,orderId:i.data.orderId,status:i.data.status,closedQuantity:a,timestamp:new Date};throw Error("Failed to close bot position")}catch(t){return this.handleBotTradingError(t,"position close")}}async getBotBalance(){try{await this.rateLimit();let t=await this.makeRequest("GET",`/v1/accounts/${this.config.accountId}/balance`);if(t.success)return t.data.map(t=>({currency:t.currency,balance:parseFloat(t.balance),equity:parseFloat(t.equity),margin:parseFloat(t.margin),freeMargin:parseFloat(t.freeMargin),marginLevel:parseFloat(t.marginLevel)}));throw Error("Failed to fetch bot balance")}catch(t){return this.handleBotTradingError(t,"balance fetch")}}async canBotTrade(t,e,r){try{await this.rateLimit();let r=(await this.getBotBalance()).find(t=>"USD"===t.currency);if(!r)return console.error("Bot: No USD balance found"),!1;let a=await this.getCurrentPrice(t),o=e*a/100;if(r.freeMargin<o)return console.error(`Bot: Insufficient margin. Required: ${o}, Available: ${r.freeMargin}`),!1;if(r.marginLevel<200)return console.error(`Bot: Margin level too low: ${r.marginLevel}%`),!1;return!0}catch(t){return console.error("Bot: Error checking trade feasibility:",t),!1}}async getBotPositions(){try{await this.rateLimit();let t=await this.makeRequest("GET",`/v1/accounts/${this.config.accountId}/positions`);if(t.success)return t.data.map(t=>({id:t.id,symbol:t.symbol,side:t.side,quantity:parseFloat(t.quantity),entryPrice:parseFloat(t.entryPrice),currentPrice:parseFloat(t.currentPrice),unrealizedPnL:parseFloat(t.unrealizedPnL),stopLoss:t.stopLoss?parseFloat(t.stopLoss):void 0,takeProfit:t.takeProfit?parseFloat(t.takeProfit):void 0,timestamp:new Date(t.timestamp)}));throw Error("Failed to fetch bot positions")}catch(t){return this.handleBotTradingError(t,"positions fetch")}}}},7153:(t,e)=>{var r;Object.defineProperty(e,"x",{enumerable:!0,get:function(){return r}}),function(t){t.PAGES="PAGES",t.PAGES_API="PAGES_API",t.APP_PAGE="APP_PAGE",t.APP_ROUTE="APP_ROUTE"}(r||(r={}))},1802:(t,e,r)=>{t.exports=r(145)}};