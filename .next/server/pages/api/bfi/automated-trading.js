"use strict";(()=>{var t={};t.id=618,t.ids=[618],t.modules={3524:t=>{t.exports=require("@prisma/client")},145:t=>{t.exports=require("next/dist/compiled/next-server/pages-api.runtime.prod.js")},7943:t=>{t.exports=require("technicalindicators")},5322:t=>{t.exports=import("ccxt")},3453:(t,e,r)=>{r.a(t,async(t,s)=>{try{r.r(e),r.d(e,{config:()=>l,default:()=>c,routeModule:()=>d});var a=r(1802),i=r(7153),n=r(6249),o=r(9797),u=t([o]);o=(u.then?(await u)():u)[0];let c=(0,n.l)(o,"default"),l=(0,n.l)(o,"config"),d=new a.PagesAPIRouteModule({definition:{kind:i.x.PAGES_API,page:"/api/bfi/automated-trading",pathname:"/api/bfi/automated-trading",bundlePath:"",filename:""},userland:o});s()}catch(t){s(t)}})},3326:(t,e,r)=>{r.a(t,async(t,s)=>{try{r.d(e,{a:()=>u});var a=r(3597),i=r(8950),n=r(3524),o=t([a,i]);[a,i]=o.then?(await o)():o;class u{constructor(){this.isRunning=!1,this.monitoringInterval=null,this.activeTrades=new Map,this.instruments=["BTC/USD","ETH/USD","EUR/USD","GBP/USD","USD/JPY","AUD/USD","USD/CAD","USD/CHF","NZD/USD","XAU/USD","XAG/USD"],this.brokerConfig=null,this.bfiStrategy=new a._,this.brokerAPIs=i.p,this.prisma=new n.PrismaClient}setBrokerConfig(t){this.brokerConfig=t}async start(){if(this.isRunning){console.log("BFI Automated Trading is already running");return}console.log("Starting BFI Automated Trading System..."),this.isRunning=!0,await this.loadActiveTrades(),this.monitoringInterval=setInterval(async()=>{await this.monitoringCycle()},3e5),await this.monitoringCycle(),console.log("BFI Automated Trading System started successfully")}async stop(){if(!this.isRunning){console.log("BFI Automated Trading is not running");return}console.log("Stopping BFI Automated Trading System..."),this.isRunning=!1,this.monitoringInterval&&(clearInterval(this.monitoringInterval),this.monitoringInterval=null),console.log("BFI Automated Trading System stopped")}async monitoringCycle(){try{console.log("Starting BFI monitoring cycle..."),await this.monitorActiveTrades(),await this.scanForNewSetups(),await this.executeValidSetups(),console.log("BFI monitoring cycle completed")}catch(t){console.error("Error in BFI monitoring cycle:",t)}}async monitorActiveTrades(){for(let[t,e]of Array.from(this.activeTrades.entries()))try{if(!this.brokerConfig)throw Error("Broker config not set");let r=await this.brokerAPIs.getCurrentPrice(this.brokerConfig,e.instrument);if(this.isStopLossHit(e,r)){await this.closeTrade(t,"stop_loss",r);continue}if(this.isTakeProfitHit(e,r)){await this.closeTrade(t,"target_hit",r);continue}e.pnl=this.calculatePnL(e,r),await this.updateTradeInDatabase(e)}catch(e){console.error(`Error monitoring trade ${t}:`,e)}}async scanForNewSetups(){for(let t of this.instruments)try{console.log(`Scanning ${t} for BFI setups...`);let e=await this.bfiStrategy.findTradingSetups(t),r=Array.from(this.activeTrades.values()),s=e.filter(t=>!r.some(e=>e.setupId===t.id));for(let e of(console.log(`Found ${s.length} new setups for ${t}`),s))await this.storeSetup(e)}catch(e){console.error(`Error scanning ${t}:`,e)}}async executeValidSetups(){try{for(let t of(await this.prisma.bFISetup.findMany({where:{status:"waiting"},include:{footprint:!0}})))try{if(!await this.validateSetup(t)){await this.markSetupInvalid(t.id);continue}await this.shouldExecuteSetup(t)&&await this.executeSetup(t)}catch(e){console.error(`Error processing setup ${t.id}:`,e)}}catch(t){console.error("Error executing valid setups:",t)}}async validateSetup(t){try{if(!this.brokerConfig)throw Error("Broker config not set");let e=await this.brokerAPIs.getCurrentPrice(this.brokerConfig,t.instrument),r=t.footprint.range;return e>=r.floor&&e<=r.base}catch(t){return console.error("Error validating setup:",t),!1}}async shouldExecuteSetup(t){try{let e=await this.brokerAPIs.getBalance(),r=this.calculateRequiredMargin(t);if(e<r)return console.log(`Insufficient balance for setup ${t.id}`),!1;if(this.calculateCurrentRisk()>.02)return console.log(`Risk limit exceeded for setup ${t.id}`),!1;if(this.activeTrades.size>=5)return console.log(`Too many active trades for setup ${t.id}`),!1;return!0}catch(t){return console.error("Error checking setup execution criteria:",t),!1}}async executeSetup(t){try{if(console.log(`Executing BFI setup: ${t.id}`),!this.brokerConfig)throw Error("Broker config not set");let e=await this.brokerAPIs.getCurrentPrice(this.brokerConfig,t.instrument),r=this.calculatePositionSize(t);if((await this.brokerAPIs.placeOrder({instrument:t.instrument,side:"bullish"===t.footprint.direction?"buy":"sell",type:"market",quantity:r,stopLoss:t.stopLoss,takeProfit:t.targets[0]})).success){let s={id:`trade_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,setupId:t.id,instrument:t.instrument,side:"bullish"===t.footprint.direction?"buy":"sell",quantity:r,entryPrice:e,stopLoss:t.stopLoss,takeProfit:t.targets[0],status:"open",pnl:0,entryTime:new Date};this.activeTrades.set(s.id,s),await this.storeTrade(s),await this.markSetupExecuted(t.id),console.log(`BFI setup executed successfully: ${s.id}`)}else console.error(`Failed to execute BFI setup: ${t.id}`)}catch(e){console.error(`Error executing setup ${t.id}:`,e)}}calculatePositionSize(t){let e=t.entryRange.midpoint,r=t.stopLoss;return 200/Math.abs(e-r)}calculateRequiredMargin(t){let e=this.calculatePositionSize(t),r=t.entryRange.midpoint;return e*r/10}calculateCurrentRisk(){let t=0;for(let e of Array.from(this.activeTrades.values())){let r=Math.abs(e.entryPrice-e.stopLoss)*e.quantity;t+=r}return t/1e4}isStopLossHit(t,e){return"buy"===t.side?e<=t.stopLoss:e>=t.stopLoss}isTakeProfitHit(t,e){return"buy"===t.side?e>=t.takeProfit:e<=t.takeProfit}calculatePnL(t,e){return"buy"===t.side?(e-t.entryPrice)*t.quantity:(t.entryPrice-e)*t.quantity}async closeTrade(t,e,r){try{let s=this.activeTrades.get(t);if(!s)return;console.log(`Closing trade ${t} - ${e}`),await this.brokerAPIs.closePosition(s.instrument),s.status="closed",s.exitTime=new Date,s.exitReason=e,s.pnl=this.calculatePnL(s,r),await this.updateTradeInDatabase(s),this.activeTrades.delete(t),console.log(`Trade ${t} closed successfully. P&L: ${s.pnl}`)}catch(e){console.error(`Error closing trade ${t}:`,e)}}async loadActiveTrades(){try{for(let t of(await this.prisma.bFITrade.findMany({where:{status:"open"}})))this.activeTrades.set(t.id,{id:t.id,setupId:t.setupId,instrument:t.instrument,side:t.side,quantity:t.quantity,entryPrice:t.entryPrice,stopLoss:t.stopLoss,takeProfit:t.takeProfit,status:t.status,pnl:t.pnl,entryTime:t.entryTime,exitTime:t.exitTime||void 0,exitReason:t.exitReason||void 0});console.log(`Loaded ${this.activeTrades.size} active trades`)}catch(t){console.error("Error loading active trades:",t)}}async storeSetup(t){try{await this.prisma.bFISetup.create({data:{id:t.id,instrument:t.instrument,monthlyBias:t.monthlyBias,weeklyBias:t.weeklyBias,riskRewardRatio:t.riskRewardRatio,stopLoss:t.stopLoss,targets:t.targets,status:t.status,footprint:{create:{id:t.footprint.id,instrument:t.footprint.instrument,timeframe:t.footprint.timeframe,direction:t.footprint.direction,strength:t.footprint.strength,volume:t.footprint.volume,isValid:t.footprint.isValid,originLow:t.footprint.origin.low,originBase:t.footprint.origin.base,originTimestamp:new Date(t.footprint.origin.timestamp),rangeFloor:t.footprint.range.floor,rangeBase:t.footprint.range.base}}}})}catch(t){console.error("Error storing setup:",t)}}async storeTrade(t){try{await this.prisma.bFITrade.create({data:{id:t.id,setupId:t.setupId,instrument:t.instrument,side:t.side,quantity:t.quantity,entryPrice:t.entryPrice,stopLoss:t.stopLoss,takeProfit:t.takeProfit,status:t.status,pnl:t.pnl,entryTime:t.entryTime,exitTime:t.exitTime,exitReason:t.exitReason}})}catch(t){console.error("Error storing trade:",t)}}async updateTradeInDatabase(t){try{await this.prisma.bFITrade.update({where:{id:t.id},data:{pnl:t.pnl,status:t.status,exitTime:t.exitTime,exitReason:t.exitReason}})}catch(t){console.error("Error updating trade:",t)}}async markSetupExecuted(t){try{await this.prisma.bFISetup.update({where:{id:t},data:{status:"active"}})}catch(t){console.error("Error marking setup as executed:",t)}}async markSetupInvalid(t){try{await this.prisma.bFISetup.update({where:{id:t},data:{status:"invalidated"}})}catch(t){console.error("Error marking setup as invalid:",t)}}async getPerformance(){try{let t=await this.prisma.bFITrade.findMany({where:{status:"closed"}}),e=t.length,r=t.filter(t=>t.pnl>0),s=t.filter(t=>t.pnl<0),a=t.reduce((t,e)=>t+e.pnl,0),i=r.reduce((t,e)=>t+e.pnl,0),n=Math.abs(s.reduce((t,e)=>t+e.pnl,0)),o=e>0?r.length/e:0,u=r.length>0?i/r.length:0,c=s.length>0?n/s.length:0,l=0,d=0,g=0;for(let e of t){(g+=e.pnl)>d&&(d=g);let t=d-g;t>l&&(l=t)}let p=t.map(t=>t.pnl),h=p.length>0?p.reduce((t,e)=>t+e,0)/p.length:0,f=p.length>0?p.reduce((t,e)=>t+Math.pow(e-h,2),0)/p.length:0,m=Math.sqrt(f);return{totalTrades:e,winningTrades:r.length,losingTrades:s.length,winRate:o,totalPnl:a,averageWin:u,averageLoss:c,profitFactor:n>0?i/n:0,maxDrawdown:l,sharpeRatio:m>0?h/m:0}}catch(t){return console.error("Error calculating performance:",t),{totalTrades:0,winningTrades:0,losingTrades:0,winRate:0,totalPnl:0,averageWin:0,averageLoss:0,profitFactor:0,maxDrawdown:0,sharpeRatio:0}}}getActiveTrades(){return Array.from(this.activeTrades.values())}getStatus(){return{isRunning:this.isRunning,activeTrades:this.activeTrades.size,lastUpdate:new Date}}}s()}catch(t){s(t)}})},9797:(t,e,r)=>{r.a(t,async(t,s)=>{try{r.r(e),r.d(e,{default:()=>n});var a=r(3326),i=t([a]);a=(i.then?(await i)():i)[0];let w=null;async function n(t,e){try{switch(t.method){case"POST":return await o(t,e);case"GET":return await u(t,e);case"PUT":return await c(t,e);case"DELETE":return await l(t,e);default:return e.status(405).json({error:"Method not allowed"})}}catch(t){return console.error("Error in automated trading API:",t),e.status(500).json({error:"Internal server error"})}}async function o(t,e){let{action:r,brokerConfig:s}=t.body;switch(r){case"start":return await d(t,e,s);case"stop":return await g(t,e);default:return e.status(400).json({error:"Invalid action"})}}async function u(t,e){let{type:r}=t.query;switch(r){case"status":return await p(t,e);case"performance":return await h(t,e);case"trades":return await f(t,e);default:return e.status(400).json({error:"Invalid type parameter"})}}async function c(t,e){let{action:r}=t.body;return"update_config"===r?await m(t,e):e.status(400).json({error:"Invalid action"})}async function l(t,e){let{action:r}=t.body;return"close_trade"===r?await y(t,e):e.status(400).json({error:"Invalid action"})}async function d(t,e,r){try{if(w)return e.status(400).json({error:"Automated trading is already running"});return(w=new a.a).setBrokerConfig(r),await w.start(),e.status(200).json({success:!0,message:"Automated BFI trading started successfully"})}catch(t){return console.error("Error starting automated trading:",t),e.status(500).json({error:"Failed to start automated trading"})}}async function g(t,e){try{if(!w)return e.status(400).json({error:"Automated trading is not running"});return await w.stop(),w=null,e.status(200).json({success:!0,message:"Automated BFI trading stopped successfully"})}catch(t){return console.error("Error stopping automated trading:",t),e.status(500).json({error:"Failed to stop automated trading"})}}async function p(t,e){try{if(!w)return e.status(200).json({isRunning:!1,activeTrades:0,lastUpdate:new Date});let t=w.getStatus();return e.status(200).json(t)}catch(t){return console.error("Error getting status:",t),e.status(500).json({error:"Failed to get status"})}}async function h(t,e){try{if(!w)return e.status(400).json({error:"Automated trading is not running"});let t=await w.getPerformance();return e.status(200).json(t)}catch(t){return console.error("Error getting performance:",t),e.status(500).json({error:"Failed to get performance"})}}async function f(t,e){try{if(!w)return e.status(200).json([]);let t=w.getActiveTrades();return e.status(200).json(t)}catch(t){return console.error("Error getting active trades:",t),e.status(500).json({error:"Failed to get active trades"})}}async function m(t,e){try{let{brokerConfig:r}=t.body;if(!w)return e.status(400).json({error:"Automated trading is not running"});return w.setBrokerConfig(r),e.status(200).json({success:!0,message:"Configuration updated successfully"})}catch(t){return console.error("Error updating config:",t),e.status(500).json({error:"Failed to update configuration"})}}async function y(t,e){try{let{tradeId:r}=t.body;if(!w)return e.status(400).json({error:"Automated trading is not running"});return e.status(200).json({success:!0,message:"Trade close request received"})}catch(t){return console.error("Error closing trade:",t),e.status(500).json({error:"Failed to close trade"})}}s()}catch(t){s(t)}})}};var e=require("../../../webpack-api-runtime.js");e.C(t);var r=t=>e(e.s=t),s=e.X(0,[989],()=>r(3453));module.exports=s})();